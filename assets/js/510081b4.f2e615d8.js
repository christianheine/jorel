"use strict";(self.webpackChunkjorel_docs=self.webpackChunkjorel_docs||[]).push([[482],{3632:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"agents/task-deep-dive","title":"Task Processing Deep Dive","description":"Tasks in JorEl are powerful abstractions that represent conversations with agents. This guide explores advanced task concepts and features.","source":"@site/docs/agents/task-deep-dive.md","sourceDirName":"agents","slug":"/agents/task-deep-dive","permalink":"/jorel/docs/agents/task-deep-dive","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"learn","previous":{"title":"Creating a Simple Agent","permalink":"/jorel/docs/agents/simple-agent"},"next":{"title":"Agents with transfer of responsibility","permalink":"/jorel/docs/agents/transfer"}}');var a=s(4848),r=s(8453);const i={sidebar_position:3},o="Task Processing Deep Dive",l={},c=[{value:"Task Lifecycle",id:"task-lifecycle",level:2},{value:"Task Structure",id:"task-structure",level:2},{value:"Understanding Threads",id:"understanding-threads",level:3},{value:"Event Tracking",id:"event-tracking",level:3},{value:"Step-by-Step Processing",id:"step-by-step-processing",level:2},{value:"Tool Call Approvals",id:"tool-call-approvals",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Serialization and Hydration",id:"serialization-and-hydration",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"task-processing-deep-dive",children:"Task Processing Deep Dive"})}),"\n",(0,a.jsx)(n.p,{children:"Tasks in JorEl are powerful abstractions that represent conversations with agents. This guide explores advanced task concepts and features."}),"\n",(0,a.jsx)(n.h2,{id:"task-lifecycle",children:"Task Lifecycle"}),"\n",(0,a.jsx)(n.p,{children:"A task goes through several states during its lifecycle:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'type TaskExecutionStatus = "pending" | "running" | "halted" | "completed";\n'})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Pending"}),": Initial state after task creation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Running"}),": Task is being processed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Halted"}),": Task stopped due to limits, approvals, or errors"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Completed"}),": Task finished successfully"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"task-structure",children:"Task Structure"}),"\n",(0,a.jsx)(n.p,{children:"A task consists of:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Threads"}),": Conversations between agents and users"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Events"}),": Record of actions taken during processing"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"State"}),": Current status and processing information"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Statistics"}),": Usage data and metrics"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"understanding-threads",children:"Understanding Threads"}),"\n",(0,a.jsx)(n.p,{children:"Each task has at least one thread (the main thread). Additional threads are created during delegation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'const task = await jorEl.team.createTask("What\'s the weather like?");\n\n// The main thread is automatically created\nconsole.log(task.threads["__main__"]);\n// {\n//   id: "__main__",\n//   agentId: "weather_agent",\n//   messages: [/* conversation messages */],\n//   events: [/* thread events */],\n//   parentThreadId: null,  // Main thread has no parent\n// }\n'})}),"\n",(0,a.jsx)(n.h3,{id:"event-tracking",children:"Event Tracking"}),"\n",(0,a.jsx)(n.p,{children:"Tasks track various events during processing:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const { events } = result.eventsWithStatistics;\n\n// Events show the full processing history\nfor (const event of events) {\n  console.log({\n    type: event.eventType,     // 'generation' | 'toolUse' | 'delegation' | 'transfer'\n    action: event.action,      // Human-readable description\n    timestamp: event.timestamp,\n    threadId: event.threadId,\n    messageId: event.messageId,\n  });\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-by-step-processing",children:"Step-by-Step Processing"}),"\n",(0,a.jsxs)(n.p,{children:["While ",(0,a.jsx)(n.code,{children:"executeTask"})," is convenient, processing tasks step-by-step gives you more control:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'const task = await jorEl.team.createTask(\n  "What\'s the weather in Sydney?"\n);\n\nlet currentTask = task;\nwhile (currentTask.status !== "completed" && currentTask.status !== "halted") {\n  // Process one step\n  currentTask = await jorEl.team.resumeTask(currentTask);\n  \n  // Check the latest event\n  const event = currentTask.events[currentTask.events.length - 1];\n  \n  // Handle different event types\n  switch (event.eventType) {\n    case "generation":\n      console.log("Agent generated a response");\n      break;\n    case "toolUse":\n      console.log("Agent used a tool");\n      if (event.toolError) {\n        console.error("Tool error:", event.toolError);\n      }\n      break;\n    case "delegation":\n      console.log("Agent delegated to:", event.delegateToAgentName);\n      break;\n    case "transfer":\n      console.log(\n        "Transfer from", event.fromAgentName,\n        "to", event.toAgentName\n      );\n      break;\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"tool-call-approvals",children:"Tool Call Approvals"}),"\n",(0,a.jsx)(n.p,{children:"You can require approval for tool usage:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'// Register tool with approval requirement\njorEl.team.addTools([{\n  name: "send_email",\n  description: "Send an email to a user",\n  requiresConfirmation: true,  // Requires approval\n  executor: sendEmail,\n  params: z.object({\n    to: z.string(),\n    subject: z.string(),\n    body: z.string(),\n  }),\n}]);\n\n// Process task until approval needed\nlet currentTask = task;\nwhile (currentTask.status !== "completed") {\n  currentTask = await jorEl.team.resumeTask(currentTask);\n  \n  if (currentTask.status === "halted" && \n      currentTask.haltReason === "approvalRequired") {\n    \n    // Get pending tool calls\n    const toolCalls = currentTask.activeThread.latestMessage.toolCalls;\n    \n    // Review and approve/reject each call\n    for (const call of toolCalls) {\n      if (call.approvalState === "requiresApproval") {\n        // Review the call\n        console.log("Tool:", call.request.function.name);\n        console.log("Args:", call.request.function.arguments);\n        \n        // Approve or reject\n        if (confirmWithUser(call)) {\n          jorEl.team.tools.approveCalls(currentTask, call.id);\n        } else {\n          jorEl.team.tools.rejectCalls(currentTask, call.id);\n        }\n      }\n    }\n    \n    // Resume processing\n    currentTask = await jorEl.team.resumeTask(currentTask);\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(n.p,{children:"Tasks can halt for various reasons:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'type TaskExecutionHaltingReason =\n  | "maxIterations"    // Too many processing steps\n  | "maxGenerations"   // Too many LLM calls\n  | "maxDelegations"   // Too many agent delegations\n  | "approvalRequired" // Tool needs approval\n  | "invalidState"     // Task in invalid state\n  | "error"           // General error\n  | "completed";      // Task completed\n\n// Handle different halt reasons\nif (task.status === "halted") {\n  switch (task.haltReason) {\n    case "maxIterations":\n      console.log("Task took too many steps");\n      break;\n    case "maxGenerations":\n      console.log("Cost limit reached");\n      break;\n    case "maxDelegations":\n      console.log("Too many delegations");\n      break;\n    case "approvalRequired":\n      console.log("Tool needs approval");\n      break;\n    case "invalidState":\n      console.log("Task in invalid state");\n      break;\n    case "error":\n      console.log("Task error");\n      break;\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"serialization-and-hydration",children:"Serialization and Hydration"}),"\n",(0,a.jsx)(n.p,{children:"Tasks can be serialized for storage and hydrated for later use:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Get task definition (for storage)\nconst definition = task.definition;\n// {\n//   id: string;\n//   status: TaskExecutionStatus;\n//   threads: { [threadId: string]: ThreadDefinition };\n//   activeThreadId: string;\n//   stats: { generations: number; delegations: number };\n//   modified: boolean;\n//   haltReason: string | null;\n// }\n\n// Store the definition (e.g., in a database)\nawait db.tasks.save(definition);\n\n// Later, hydrate the task\nconst storedDefinition = await db.tasks.get(taskId);\nconst hydratedTask = jorEl.team.hydrateTask(storedDefinition);\n\n// Continue processing\nconst result = await jorEl.team.executeTask(hydratedTask);\n"})}),"\n",(0,a.jsx)(n.p,{children:"This enables:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Saving long-running tasks"}),"\n",(0,a.jsx)(n.li,{children:"Implementing approval workflows"}),"\n",(0,a.jsx)(n.li,{children:"Building user interfaces for task monitoring"}),"\n",(0,a.jsx)(n.li,{children:"Creating task queues and job systems"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Appropriate Limits"}),": Always set reasonable limits"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"   const result = await jorEl.team.executeTask(task, {\n     limits: {\n       maxIterations: 10,\n       maxGenerations: 6,\n       maxDelegations: 2,\n     },\n   });\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Event Monitoring"}),": Track events for debugging and monitoring"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"   const { events, stats, tokens } = task.eventsWithStatistics;\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"3",children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Error Recovery"}),": Handle halted tasks appropriately"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'   if (task.status === "halted") {\n     // Log the reason\n     console.log(`Task halted: ${task.haltReason}`);\n     \n     // Take appropriate action\n     if (task.haltReason === "maxGenerations") {\n       // Maybe increase the limit and retry\n       task = await jorEl.team.executeTask(task, {\n         limits: { maxGenerations: 12 },\n       });\n     }\n   }\n'})}),"\n",(0,a.jsxs)(n.ol,{start:"4",children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Approval Workflows"}),": Design clear approval processes"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'   // Example approval workflow\n   async function processWithApprovals(task) {\n     while (task.status !== "completed") {\n       task = await jorEl.team.resumeTask(task);\n       if (task.status === "halted" && \n           task.haltReason === "approvalRequired") {\n         await handleApprovals(task);\n       }\n     }\n     return task;\n   }\n'})}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Learn about ",(0,a.jsx)(n.a,{href:"/jorel/docs/agents/delegation",children:"Delegation"})," between agents"]}),"\n",(0,a.jsxs)(n.li,{children:["Explore ",(0,a.jsx)(n.a,{href:"/jorel/docs/agents/transfer",children:"Transfer"})," of control"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(6540);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);